## Kick Start 2021 Round-B

é¢˜ç›®ï¼š[Kick Start 2021 Round-B](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b) .

## Increasing Substring

è¾“å‡ºå­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦çš„æœ€é•¿ Increasing Substring çš„é•¿åº¦ï¼Œéå¸¸ç®€å•çš„åŠ¨æ€è§„åˆ’é—®é¢˜ã€‚

å®šä¹‰ `dp[i]` æ˜¯ä»¥ `str[i]` ç»“å°¾çš„æœ€é•¿ Increasing Substring çš„é•¿åº¦ã€‚

**è½¬ç§»æ–¹ç¨‹**

```text
dp[i] = dp[i-1] + 1, if str[i-1] < str[i]
dp[i] = 1, otherwise
```

æ˜¾ç„¶æ˜¯å¯ä»¥è¿›è¡Œç©ºé—´ä¼˜åŒ–çš„ï¼Œç„¶è€Œã€Œå¯ä»¥ä½†æ²¡å¿…è¦ã€ã€‚

**ä»£ç å®ç°**

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;
int cnt = 1;
void solve(string &str, int n)
{
    vector<int> dp(n, 1);
    for (int i = 1; i < n; i++)
    {
        if (str[i - 1] < str[i])
            dp[i] = dp[i - 1] + 1;
    }
    printf("Case #%d:", cnt++);
    for (int x : dp) printf(" %d", x);
    printf("\n");
}
int main()
{
    int t, n;
    cin >> t;
    cin.ignore();
    while (t--)
    {
        string str;
        cin >> n;   cin.ignore();
        cin >> str; cin.ignore();
        solve(str, n);
    }
}
```



## Longest Progression

ç»™å®šä¸€ä¸ªæ•°ç»„ $A[n]$ ï¼Œåœ¨å…è®¸æ”¹åŠ¨ä¸€ä¸ªå…ƒç´ çš„æ¡ä»¶ä¸‹ï¼Œæ‰¾åˆ°æœ€é•¿çš„ç­‰å·®æ•°åˆ—çš„é•¿åº¦ï¼ˆè¿™ä¸ªæ•°åˆ—åœ¨æ•°ç»„ä¸­å¿…é¡»æ˜¯è¿ç»­çš„ï¼‰ã€‚

ä»¤ï¼š

- `left[i]` è¡¨ç¤ºä»ä½ç½® `i` å‘å·¦å»¶ä¼¸ï¼Œèƒ½å¤Ÿå¾—åˆ°çš„æœ€é•¿ç­‰å·®æ•°åˆ—çš„é•¿åº¦ï¼ˆåŒ…å« `a[i]` ï¼‰ï¼›
- `right[i]` è¡¨ç¤ºä»ä½ç½® `i` å‘å³å»¶ä¼¸ï¼Œèƒ½å¤Ÿå¾—åˆ°çš„æœ€é•¿ç­‰å·®æ•°åˆ—çš„é•¿åº¦ï¼ˆåŒ…å« `a[i]` ï¼‰ã€‚

æ˜¾ç„¶ï¼Œå¦‚æœæˆ‘ä»¬å…è®¸æ”¹åŠ¨ä¸€ä¸ªä½ç½®ï¼Œé‚£ä¹ˆæ‰«ææ•°ç»„ä¸­çš„ä»»æ„ä¸€ä¸ªæ•° $a_i$ ï¼Œåˆ¤æ–­æ”¹åŠ¨ $a_i$ æ˜¯å¦èƒ½ç»„åˆå¾—åˆ°ä¸€ä¸ªæ›´é•¿çš„ç­‰å·®æ•°åˆ—ï¼š

- ç»„åˆ `left[i-1]` å’Œ `right[i+1]`
  - æ¡ä»¶ä¸ºï¼š$a_{i+2} - a_{i+1} = a_{i-1} - a_{i-2} \text{ and } a_{i+1} - a_{i-1} = 2(a_{i-1} - a_{i-2})$
- ç»„åˆ `left[i-1]` å’Œ `a[i], a[i+1]`
  - æ¡ä»¶ä¸ºï¼š$a_{i+1} - a_{i-1} = 2(a_{i-1} - a_{i-2})$ 
- ç»„åˆ `right[i+1]` å’Œ `a[i], a[i-1]`
  - æ¡ä»¶ä¸ºï¼š$a_{i+1} - a_{i-1} = 2(a_{i+2} - a_{i+1})$



**ä»£ç å®ç°**

```cpp
#include <iostream>
#include <vector>
using namespace std;
int cnt = 1;
int solve(int n, vector<int> &a)
{
    if (n <= 3) return n;
    vector<int> left(n, 2), right(n, 2);
    left[0] = right[n - 1] = 1;
    for (int i = 2; i < n; i++)
        if ((a[i] - a[i - 1]) == (a[i - 1] - a[i - 2]))
            left[i] = left[i - 1] + 1;
    for (int i = n - 3; i >= 0; i--)
        if ((a[i + 2] - a[i + 1]) == (a[i + 1] - a[i]))
            right[i] = right[i + 1] + 1;
    int ans = max(left[n - 2] + 1, right[1] + 1);
    for (int i = 1; i < n - 1; i++)
    {
        // left[i-1] + 1 å…¶å®å°±æ˜¯ç»„åˆ left[i-1] å’Œ a[i], å› ä¸ºå…è®¸æ”¹åŠ¨ a[i], æ‰€ä»¥è¿™æ˜¯å¿…ç„¶èƒ½å®ç°çš„
        // right[i+1] ä¸ä¹‹åŒç†
        ans = max(ans, max(left[i - 1] + 1, right[i + 1] + 1));
        if (i >= 2 && a[i + 1] - a[i - 1] == 2 * (a[i - 1] - a[i - 2]))
            ans = max(ans, left[i - 1] + 2);
        if (i + 2 < n && a[i + 1] - a[i - 1] == 2 * (a[i + 2] - a[i + 1]))
            ans = max(ans, right[i + 1] + 2);
        if (i >= 2 && i + 2 < n &&
            a[i + 1] - a[i - 1] == 2 * (a[i - 1] - a[i - 2]) &&
            a[i - 1] - a[i - 2] == a[i + 2] - a[i + 1])
            ans = max(ans, left[i - 1] + right[i + 1] + 1);
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(0);
    int t, n;
    cin >> t;
    while (t--)
    {
        cin >> n;
        vector<int> nums(n);
        for (int i = 0; i < n; i++) cin >> nums[i];
        printf("Case #%d: %d\n", cnt++, solve(n, nums));
    }
}
```



## Consecutive Primes

ç»™å®šä¸€ä¸ªæ•´æ•° $n$ ï¼Œæ±‚ä¸¤ä¸ªç›¸é‚»çš„ç´ æ•° $l, r$ ( $l \cdot r \le n$  ) ï¼Œä¸”ä½¿å¾— $l \cdot r$ çš„ä¹˜ç§¯æœ€å¤§ï¼Œè¾“å‡ºè¿™ä¸ªæœ€å¤§ä¹˜ç§¯ã€‚

**æ€è·¯**

- ä»¤ $k = \sqrt{n}$ , æ±‚å‡º $k$ å·¦ä¾§çš„æœ€å¤§ç´ æ•°ä¸º $l$ ï¼Œ$k$ å³ä¾§çš„æœ€å°ç´ æ•°ä¸º $r$ ã€‚
- å¦‚æœ $l \cdot r \le n$ ï¼Œé‚£ä¹ˆè¿”å› $l \cdot r$ ã€‚
- å¦åˆ™ï¼Œå­˜åœ¨ $l_2 < l$ ï¼Œ$l_2$ æ˜¯å°äº $l$ çš„æœ€å¤§ç´ æ•°ï¼Œè¿”å› $l_2 \cdot l$ ã€‚



**æ­£ç¡®æ€§è¯æ˜**

- æœ€ç†æƒ³çš„æƒ…å†µæ˜¯ $k = \sqrt{n}$ ä¸ºä¸€ä¸ªæ•´æ•°ï¼Œé‚£ä¹ˆ $l = r = \sqrt{n}$ å¯ä»¥å¾—åˆ°æœ€å¤§ä¹˜ç§¯ $n$ ã€‚ä½†é¢˜ç›®è¦æ±‚ä¸º 2 ä¸ªç›¸é‚»çš„ä¸åŒç´ æ•°ã€‚
- å› æ­¤ï¼Œè¿™ 2 ä¸ªç´ æ•°å¿…ç„¶æ˜¯ä¸‹é¢ 2 ç§æƒ…å†µä¹‹ä¸€ï¼ˆå¦åˆ™ä¸èƒ½ä¿è¯ $l \cdot r \le n$ ï¼‰ï¼š
  - ä¸€ä¸ªåœ¨ $k$ çš„å·¦ä¾§ï¼Œä¸€ä¸ªåœ¨ $k$ çš„å³ä¾§ã€‚
  - ä¸¤ä¸ªéƒ½åœ¨ $k$ çš„å·¦ä¾§ã€‚
- æ˜¾ç„¶ï¼Œå¦‚æœã€Œä¸€å·¦ä¸€å³ã€çš„æƒ…å†µå­˜åœ¨ï¼Œå®ƒçš„ä¹˜ç§¯å¿…ç„¶å¤§äºã€Œå‡åœ¨å·¦ä¾§ã€è¿™ä¸ªä¹˜ç§¯ï¼Œå› ä¸º $l_2 < l < r$ã€‚



**æ—¶é—´å¤æ‚åº¦**

- ç´ æ•°åˆ¤å®šå¯ä»¥åœ¨ $O(\sqrt{k})$ å†…å®Œæˆã€‚
- æ ¹æ® [Prime Gap](https://en.wikipedia.org/wiki/Prime_gap) ï¼Œä¸¤ä¸ªç›¸é‚»ç´ æ•° $p_{i}, p_{i+1}$ ä¹‹å·®å¯ä»¥è®°ä¸º $g_i$ .
- æœ€åæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ° 3 ä¸ªç›¸é‚»çš„ç´ æ•°ï¼ˆéœ€è¦æ‰«æ 2 ä¸ª Prime Gapï¼‰ï¼Œå› æ­¤ç®—æ³•å¤æ‚åº¦ä¸º $O((g_l + g_r) \cdot \sqrt{k})$ï¼Œ$k = \sqrt{n}$ .
- é¢˜ç›®ç»™å®š $n \le 10^{18}$ ï¼Œå› æ­¤ $k \le 10^9$ ã€‚æŸ¥è¡¨å¾— $g_l, g_r$ åœ¨ 282 - 288 ä¹‹é—´ï¼Œå› è€Œè¿™ä¸€ç®—æ³•å¤æ‚åº¦æ˜¯å¯ä»¥æ¥å—çš„ã€‚



**ä»£ç å®ç°**

```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
int cnt = 1;
bool isprime(uint64_t k)
{
    for (uint64_t i = 2; i * i <= k; i++)
        if (k % i == 0)  return false;
    return true;
}
uint64_t solve(uint64_t n)
{
    uint64_t k = sqrt(n);
    uint64_t l = k, r = k + 1;
    while (!isprime(l)) l--;
    while (!isprime(r)) r++;
    if (l * r <= n) return l * r;
    uint64_t l2 = l - 1;
    while (!isprime(l2)) l2--;
    return l * l2;
}
int main()
{
    int t;
    cin >> t;
    cin.ignore();
    while (t--)
    {
        uint64_t n;
        cin >> n;
        cin.ignore();
        printf("Case #%d: %llu\n", cnt++, solve(n));
    }
}
```



## Truck Delivery

ç»™å®šä¸€ä¸ªæ ‘ $G$ ï¼Œæ¯ä¸ªé¡¶ç‚¹ $1-n$ ä»£è¡¨ä¸€ä¸ªåŸå¸‚ï¼Œæ¯ä¸ªè¾¹ä»£è¡¨ä¸€ä¸ªå…¬è·¯ï¼Œå…¬è·¯æœ‰ 2 ä¸ªå‚æ•° `(limit, amount)` ã€‚å¦‚æœç»è¿‡è¿™ä¸€å…¬è·¯çš„å¡è½¦ï¼Œå®ƒçš„ `weight` å¤§äºç­‰äº `limit` ï¼Œé‚£ä¹ˆéœ€è¦æ”¶è´¹ `amount` ï¼Œå¦åˆ™ä¸æ”¶è´¹ã€‚

é—®ï¼šç»™å®šä¸€ä¸ª $Q$ ï¼Œè¡¨ç¤ºå·¥ä½œçš„å¤©æ•°ï¼Œæ¯ä¸€å¤©æœ‰ 2 ä¸ªå‚æ•° $Q_i = (C, W)$ ï¼Œè¡¨ç¤ºä»åŸå¸‚ $C$ å‡ºå‘ï¼Œç›®çš„åœ°æ˜¯åŸå¸‚ $1$ ï¼Œæ˜¾ç„¶è¿™æ ·çš„è·¯å¾„æ˜¯å”¯ä¸€çš„ã€‚å¡è½¦çš„ `weight` ä¸º $W$ ï¼Œé‚£ä¹ˆä» $C \rightarrow 1$ çš„è¿™ä¸€è·¯å¾„ä¸Šï¼Œæ¯ä¸ªå…¬è·¯éƒ½å¯¹åº”ä¸€ä¸ªæ”¶è´¹ã€‚å¯¹äºæ¯ä¸ª $Q_i$ï¼Œæ±‚è¿™ä¸€å¤©ä¸­ï¼Œæ‰€æœ‰æ”¶è´¹çš„æœ€å¤§å…¬å› å­ã€‚

### BFS/DFS

æœ€ç®€å•ï¼Œä¹Ÿæ˜¯æœ€æš´åŠ›çš„è§£æ³•ã€‚

**æ€è·¯**

- å»ºå›¾å®Œæˆåï¼Œæ‰§è¡Œ `bfs(1)` ï¼Œä»åŸå¸‚ $1$ å¼€å§‹ BFSï¼Œæ‰¾åˆ° $1$ åˆ°å…¶ä»–åŸå¸‚ $2-n$ çš„æ‰€æœ‰è·¯å¾„ã€‚è·¯å¾„é€šè¿‡ä¸€ä¸ªæ•°ç»„ `pre` è®°å½•ï¼Œ`pre[x]` è¡¨ç¤º `x` çš„å‰é©±åŸå¸‚ã€‚
- å¯¹äºæ¯ä¸€ä¸ª $Q_i = (C,W)$ ï¼Œæ‰¾åˆ°ä» $C \rightarrow 1$ çš„è·¯å¾„ï¼Œå¹¶æ‰¾åˆ°æ‰€æœ‰ `amount` çš„æœ€å¤§å…¬å› å­ã€‚

- æ—¶é—´å¤æ‚åº¦ä¸º $O(N + Q(N + \log{A}))$ , $A$ æ˜¯ `amount` çš„æœ€å¤§å€¼ã€‚
- æ˜¾ç„¶ï¼Œè¿™ä¸ªå¤æ‚åº¦å¯¹äº Test Case 2 æ¥è¯´æ˜¯ä¸å¯æ¥å—çš„ã€‚
- ç¬¬ä¸€æ­¥çš„ BFS ä¹Ÿå¯ä»¥æ¢æˆ DFS ï¼Œå› ä¸ºåœ¨æ ‘ä¸­ï¼Œåªè¦éå†ä¸€æ¬¡ï¼Œå³å¯æ‰¾åˆ° $1$ åˆ° $2-n$ çš„è·¯å¾„ã€‚



**ä»£ç å®ç°**

ğŸ¥¸ è¢«æ•°æ®èŒƒå›´ææ­»äº†ï¼Œ`amount` çš„èŒƒå›´æ˜¯ $10^{18}$ ï¼Œå› æ­¤å¿…é¡»ç”¨ `uint64_t` ï¼Œæˆ‘æ”¹äº†æ•°æ®èŒƒå›´ï¼Œä½†å¿˜äº†æ”¹ `ans` çš„ç±»å‹ï¼›æ”¹äº† `ans` çš„ç±»å‹ï¼Œä½†å¿˜äº†æ”¹ `gcd` çš„å‚æ•°ï¼›æ”¹äº† `gcd` çš„å‚æ•°ï¼Œä½†å¿˜äº†æ”¹ `gcd` çš„è¿”å›å€¼ã€‚æœ€åé€¼å¾—æˆ‘ Ctrl+F æŠŠ `int` å…¨éƒ¨æ›¿æ¢ä¸º `uint64_t` ã€‚

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;
// 'first' is load-limit, 'second' is amount
typedef pair<uint64_t, uint64_t> node_t;
uint64_t cnt = 1;
unordered_map<uint64_t, unordered_map<uint64_t, node_t>> graph;
uint64_t gcd(uint64_t a, uint64_t b) { return b == 0 ? a : gcd(b, a % b); }
vector<uint64_t> bfs(uint64_t n, uint64_t start)
{
    vector<uint64_t> vis(n + 1, false), pre(n + 1, 0);
    queue<uint64_t> q;
    vis[start] = true, q.push(start);
    while (!q.empty())
    {
        uint64_t vex = q.front();
        q.pop();
        for (auto &p : graph[vex])
        {
            uint64_t adjacent = p.first;
            if (!vis[adjacent])
                vis[adjacent] = true, q.push(adjacent), pre[adjacent] = vex;
        }
    }
    return move(pre);
}

int main()
{
    ios::sync_with_stdio(0);
    uint64_t t, n, q;
    uint64_t x, y, limit, amount, city, weight;
    cin >> t;
    while (t--)
    {
        cin >> n >> q;
        graph.clear();
        for (uint64_t i = 0; i < n - 1; i++)
        {
            cin >> x >> y >> limit >> amount;
            graph[x][y] = graph[y][x] = {limit, amount};
        }
        auto pre = bfs(n, 1);
        cout << "Case #" << cnt++ << ": ";
        while (q--)
        {
            cin >> city >> weight;
            uint64_t cur = city, ans = 0;
            while (cur != 1)
            {
                uint64_t prev = pre[cur];
                auto [limit, amount] = graph[prev][cur];
                if (weight >= limit) ans = gcd(amount, ans);
                cur = prev;
            }
            cout << ans << " ";
        }
        cout << '\n';
    }
}
```



### Segement Tree

å®˜æ–¹é¢˜è§£ä½¿ç”¨äº†çº¿æ®µæ ‘ (Segement Tree) ï¼Œä½†æˆ‘ä¸ä¼šè¿™ä¸ªæ•°æ®ç»“æ„ ğŸ˜… , TO BE DONE.

