## [Jan, 2021] æ¯æ—¥ä¸€é¢˜

è®°å½• Leetcode çš„æ¯æ—¥ä¸€é¢˜ã€‚

## äº¤æ¢å­—ç¬¦ä¸²ä¸­çš„å…ƒç´ 

æ—¥æœŸï¼š2021/1/11

é¢˜ç›®ï¼š[1202. äº¤æ¢å­—ç¬¦ä¸²ä¸­çš„å…ƒç´ ](https://leetcode-cn.com/problems/smallest-string-with-swaps/) ã€‚

å¯äº¤æ¢çš„ `pairs` å®é™…ä¸Šæ„æˆä¸€ä¸ªå›¾ï¼Œè¯¥å›¾ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„å­—ç¬¦ï¼ˆé€šè¿‡å­—ç¬¦çš„ä¸‹æ ‡ä½œä¸ºèŠ‚ç‚¹æ ‡è®°ï¼‰éƒ½èƒ½å¤Ÿç›¸äº’äº¤æ¢ï¼Œæ­¤å¤„é€šè¿‡å¹¶æŸ¥é›†è®°å½•è¿™ä¸ª `pairs` ã€‚

ä¸‹é¢ä»¥ `s = "dcab", pairs = [[0,3],[1,2]]` æ¥è¯´æ˜æ€è·¯ã€‚

é¦–å…ˆé€šè¿‡å¹¶æŸ¥é›†å¤„ç† `paris` ï¼Œ`[0, 3], [1, 2]` å¯ä»¥ä»»æ„äº¤æ¢ï¼Œé€šè¿‡ `map<int, vector>` è®°å½•å¯ä»¥ä»»æ„äº¤æ¢çš„èŠ‚ç‚¹ï¼ˆå³ã€Œåˆ†ç¦»ã€å‡ºå›¾ä¸­çš„æ¯ä¸€ä¸ªè¿é€šåˆ†é‡ï¼‰ï¼Œæ‰€ä»¥ï¼š

```
table[0] = [0, 3]
table[1] = [1, 2]
```

éå†è¿™ä¸ª `table` ï¼Œå°†æ¯ä¸ªå­—ä¸²æ’åºåï¼Œè¦†ç›–åˆ°å¯¹åº”çš„ä½ç½®ä¸Šã€‚

```cpp
class Solution {
public:
    vector<int> root;
    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) 
    {
        int n = s.length();
        root.resize(n, -1);
        for (auto &v: pairs) merge(v[0], v[1]);

        unordered_map<int, vector<int>> table;
        for (int i=0; i<n; i++) table[find(i)].push_back(i);

        for (auto &[x, v]: table)
        {
            string buf;
            for (int i: v) buf.push_back(s[i]);
            sort(buf.begin(), buf.end());
            int j = 0;
            for (int i: v) s[i] = buf[j++];
        }
        return s;
    }
    int find(int x)  { return root[x] == -1 ? x : root[x] = find(root[x]); }
    void merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (x != y) root[y] = x;
    }
};
```

## å†—ä½™è¿æ¥

æ—¥æœŸï¼š2021/1/13

é¢˜ç›®ï¼š[684. å†—ä½™è¿æ¥](https://leetcode-cn.com/problems/redundant-connection/) ã€‚

å¹¶æŸ¥é›†æ°´é¢˜ã€‚æ‰¾åˆ°ç¬¬ä¸€ä¸ªæˆç¯çš„è¾¹å¹¶è¿”å›ã€‚

```cpp
class Solution {
public:
    vector<int> root;
    vector<int> findRedundantConnection(vector<vector<int>>& edges) 
    {
        int n = edges.size();
        root.resize(n+1, -1);
        for (auto &v: edges)
        {
            int x = find(v[0]), y = find(v[1]);
            if (x == y) return v;
            else root[y] = x;
        }
        return {};
    }
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
};
```

æ‹“å±•é¢˜ç›®ï¼š[685. å†—ä½™è¿æ¥ II](https://leetcode-cn.com/problems/redundant-connection-ii/) ï¼Œé¢˜è§£[åœ¨æ­¤](https://www.cnblogs.com/sinkinben/p/13019988.html)ã€‚

## æ‰“ç –å—

æ—¥æœŸï¼š2021/1/16

é¢˜ç›®ï¼š[803. æ‰“ç –å—](https://leetcode-cn.com/problems/bricks-falling-when-hit/) ã€‚

å‚è€ƒå®˜æ–¹é¢˜è§£ã€‚

```cpp
class Solution {
public:
    int rows, cols, roof;
    vector<int> root, size;
    const vector<vector<int>> directions = {{0,1}, {1,0}, {0,-1}, {-1, 0}};

    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
    void merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (x != y) root[x] = y, size[y] += size[x];
    }

    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
        vector<int> result(hits.size(), 0);
        if (grid.size() == 0 || grid[0].size() == 0) return result;

        auto copy = grid;
        rows = grid.size(), cols = grid[0].size();
        for (auto &v: hits) copy[v[0]][v[1]] = 0;

        roof = rows * cols;
        root.resize(roof+1, -1), size.resize(roof+1, 1);
        for (int j=0; j<cols; j++)
            if (copy[0][j] == 1)
                merge(j, roof);
        
        for (int i=1; i<rows; i++)
        {
            for (int j=0; j<cols; j++)
            {
                if (copy[i][j] == 1)
                {
                    if (copy[i-1][j] == 1) merge(getID(i-1, j), getID(i, j));
                    if (j > 0 && copy[i][j-1] == 1) merge(getID(i, j-1), getID(i, j));
                }
            }
        }

        int hitlen = hits.size();
        for (int i=hitlen-1; i>=0; i--)
        {
            int x = hits[i][0], y = hits[i][1];
            if (grid[x][y] == 0) continue;

            int before = size[find(roof)];
            // è¡¥ä¸Šç –å—
            if (x == 0) merge(y, roof);
            for (auto &d: directions)
            {
                int a = x+d[0], b = y+d[1];
                if (checkIndex(a, b) && copy[a][b] == 1)
                    merge(getID(x, y), getID(a, b));
            }
            
            int after = size[find(roof)];
            result[i] = max(0,(after - before - 1));
            copy[x][y] = 1;
        }
        return result;
    }
    int getID(int i, int j) { return i*cols + j; }
    bool checkIndex(int x, int y) { return 0<=x && x<rows && 0<=y && y<cols;}
};
```

## ç¼€ç‚¹æˆçº¿

æ—¥æœŸï¼š2021/1/17

é¢˜ç›®ï¼š[1232. ç¼€ç‚¹æˆçº¿](https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/) ã€‚

æ–œç‡å…¬å¼ï¼š
$$
\frac{y_1 - y_0}{x_1 - x_0} = \frac{y_2 - y_0}{x_2 - x_0}
$$
è€ƒè™‘ç›´çº¿ä¸ $y$ è½´å¹³è¡Œçš„æƒ…å†µï¼š
$$
(y_1 - y_0)(x_2 - x_0) = (x_1 - x_0)(y_2 - y_0)
$$
ä»£ç å®ç°ï¼š

```cpp
class Solution {
public:
    bool checkStraightLine(vector<vector<int>>& coordinates) {
        int n = coordinates.size();
        if (n <= 2) return true;
        int x0 = coordinates[0][0], y0 = coordinates[0][1];
        int x1 = coordinates[1][0], y1 = coordinates[1][1];
        int dy = y1 - y0, dx = x1 - x0;
        for (int i=2; i<n; i++)
        {
            int x2 = coordinates[i][0], y2 = coordinates[i][1];
            if (dy * (x2 - x0) != dx * (y2 - y0)) return false;
        }
        return true;
    }
};
```

## è´¦æˆ·åˆå¹¶

æ—¥æœŸï¼š2021/1/18

é¢˜ç›®ï¼š[721. è´¦æˆ·åˆå¹¶](https://leetcode-cn.com/problems/accounts-merge/)ã€‚

è¿˜æ˜¯å¹¶æŸ¥é›†ï¼Œé€šè¿‡ `email` å»ºç«‹å¹¶æŸ¥é›†ï¼Œåœ¨åŒä¸€ä¸ªè”é€šåˆ†é‡ä¸­çš„æ‰€æœ‰ `email` éƒ½å±äºåŒä¸€ä¸ªä¸»äººã€‚

`mail2name` è®°å½•äº†æ‰€æœ‰ `email` å¯¹åº”çš„ä¸»äººã€‚

ç‰ˆæœ¬ä¸€ï¼šæ‰€æœ‰è¿‡ç¨‹é€šè¿‡ `string email` ä½œä¸º `key`ï¼Œæ—¶é—´å’Œç©ºé—´æ•ˆç‡ä½ã€‚

```cpp
class Solution {
public:
    const string NIL = "nil";
    unordered_map<string, string> root;
    unordered_map<string, string> mail2name;
    string find(const string x) { return root[x] == NIL ? x : root[x] = find(root[x]); }
    void merge(string x, string y)
    {
        x = find(x), y = find(y);
        if (x != y) root[y] = x;
    }
    
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) 
    {
        // init root
        for (auto &v: accounts)
        {
            int size = v.size();
            for (int i=1; i<size; i++)
                mail2name[v[i]] = v[0], root[v[i]] = NIL;
        }
        // merge
        for (auto &v: accounts)
        {
            int size = v.size();
            for (int i=2; i<size; i++) merge(v[1], v[i]);
        }
        // split components
        unordered_map<string, vector<string>> components;
        for (auto &[k, v]: root)
            components[find(k)].emplace_back(k);
        
        vector<vector<string>> result;
        for (auto &[k, v]: components)
        {
            vector<string> people;
            people.emplace_back(mail2name[k]);
            sort(v.begin(), v.end());
            for (auto &mail: v)
                people.emplace_back(mail);
            result.emplace_back(people);
        }
        return result;
    }
};
```

ç‰ˆæœ¬äºŒï¼šæŠŠ `string email` æ˜ å°„ä¸ºä¸€ä¸ª `int`ï¼Œæ—¶é—´æ•ˆç‡è¶…è¿‡ 98% .

```cpp
class Solution {
public:
    vector<int> root;
    unordered_map<string, int> email2id;
    unordered_map<int, string> id2email, id2name;

    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }

    void merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (x!=y) root[y] = x;
    }
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) 
    {
        // init
        int n = initmap(accounts);
        root.resize(n, -1);
        // merge
        for (auto &v: accounts)
        {
            int size = v.size();
            for (int i=2; i<size; i++)
                merge(email2id[v[1]], email2id[v[i]]);
        }
        // split components
        unordered_map<int, vector<int>> components;
        for (int k = 0; k < n; k++) components[find(k)].push_back(k);
        
        vector<vector<string>> result;
        for (auto &[k, v]: components)
        {
            vector<string> people;
            people.emplace_back(id2name[k]);
            sort(v.begin(), v.end(), [&](int x, int y) { return id2email[x] < id2email[y]; });
            for (int x: v) people.emplace_back(id2email[x]);
            result.emplace_back(people);
        }
        return result;
    }
    int initmap(vector<vector<string>> &accounts)
    {
        int id = 0;
        for (auto &v: accounts)
        {
            int size = v.size();
            for (int i=1; i<size; i++)
                if (email2id.count(v[i]) == 0)
                    email2id[v[i]] = id, id2email[id] = v[i], id2name[id] = v[0], id++;
        }
        return id;
    }
};
```

## è¿æ¥æ‰€æœ‰ç‚¹çš„æœ€å°è´¹ç”¨

æ—¥æœŸï¼š2020/1/19

é¢˜ç›®ï¼š[1584. è¿æ¥æ‰€æœ‰ç‚¹çš„æœ€å°è´¹ç”¨](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

æœ€å°ç”Ÿæˆæ ‘ï¼Œè¿™é‡Œç”¨çš„æ˜¯ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–çš„ Kruskal ç®—æ³•ã€‚

Kruskal çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(m\log{m})$ , $m$ æ˜¯è¾¹çš„æ•°ç›®ï¼Œæ­¤å¤„ $m = n^2$ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2 \log{n})$ .

å®æµ‹ï¼šå¦‚æœç”¨ `vector` è®°å½•è¾¹é›†åˆï¼Œå¹¶ä½¿ç”¨ `sort` æ’åºï¼Œä¼šè¶…æ—¶ã€‚æ‰€ä»¥ï¼Œæœ€å¥½ç›´æ¥ä¸Š**ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ç‰ˆæœ¬**ã€‚

```cpp
struct compare
{
    bool operator()(const vector<int> &x, const vector<int> &y)
    { return x[2] > y[2]; }
};
class Solution
{
public:
    vector<int> root;
    int minCostConnectPoints(vector<vector<int>> &points)
    {
        int n = points.size();
        if (n <= 1) return 0;
        root.resize(n, -1);
        priority_queue<vector<int>, vector<vector<int>>, compare> edges;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                edges.push({i, j, distance(points[i], points[j])});
        int mincost = 0, needs = n - 1;
        while (!edges.empty() && needs)
        {
            auto e = edges.top();
            edges.pop();
            int x = find(e[0]), y = find(e[1]);
            if (x != y)
            {
                mincost += e[2];
                root[y] = x;
                needs--;
            }
        }
        return mincost;
    }
    int distance(vector<int> &v1, vector<int> &v2) { return abs(v1[0] - v2[0]) + abs(v1[1] - v2[1]); }
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
};

```

## ä¸‰ä¸ªæ•°çš„æœ€å¤§ä¹˜ç§¯

æ—¥æœŸï¼š2020/1/20

é¢˜ç›®ï¼š[628. ä¸‰ä¸ªæ•°çš„æœ€å¤§ä¹˜ç§¯](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)

ç¬¬ä¸€ç›´è§‰ï¼šæŒ‘é€‰å‡ºæœ€å¤§çš„ä¸‰ä¸ªæ•°å­— `{a, b, c}`ã€‚è€ƒè™‘åˆ°ã€Œè´Ÿè´Ÿå¾—æ­£ã€ï¼Œè¿˜éœ€è¦æŒ‘é€‰å‡ºæœ€å°çš„ 2 ä¸ªæ•°å­— `{x, y}`ã€‚æœ€åè¿”å› `max(a*b*c, x*y*max(a,b,c))` .

ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—å®ç°ã€‚

```cpp
class Solution {
public:
    int maximumProduct(vector<int>& nums) 
    {
        int n = nums.size();
        priority_queue<int> minval;
        priority_queue<int, vector<int>, greater<int>> maxval;
        for (int i=0; i<3; i++) maxval.push(nums[i]), minval.push(nums[i]);
        minval.pop();
        for (int i=3; i<n; i++)
        {
            int x = nums[i];
            maxval.push(x), minval.push(x);
            maxval.pop(), minval.pop();
        }
        int a,b,c,x,y;
        a = maxval.top(), maxval.pop();
        b = maxval.top(), maxval.pop();
        c = maxval.top(), maxval.pop();
        x = minval.top(), minval.pop();
        y = minval.top(), minval.pop();
        return max(a*b*c, x*y*c);
    }
};
```

ä»…ä½¿ç”¨å±€éƒ¨å˜é‡ï¼š

```cpp
class Solution {
public:
    const int INTMAX = 0x7fffffff, INTMIN=0x80000000;
    int maximumProduct(vector<int>& nums) {
        int a,b,c,x,y;
        a = b = c = INTMIN, x = y = INTMAX;
        // assume: a >= b >= c and x <= y
        for (int e: nums)
        {
            if (e < x) y = x, x = e;
            else if (e < y) y = e;
            
            if (e > a) c = b, b = a, a = e;
            else if (e > b) c = b, b = e;
            else if (e > c) c = e;
        }
        return max(a*b*c, x*y*a);
    }
};
```

##  æ‰¾åˆ°æœ€å°ç”Ÿæˆæ ‘é‡Œçš„å…³é”®è¾¹å’Œä¼ªå…³é”®è¾¹

é¢˜ç›®ï¼š[1489. æ‰¾åˆ°æœ€å°ç”Ÿæˆæ ‘é‡Œçš„å…³é”®è¾¹å’Œä¼ªå…³é”®è¾¹](https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/)ã€‚

å¹¶æŸ¥é›† + Kruskal. å…ˆé€šè¿‡ `map<int, vector<int>>` å°†è¾¹æŒ‰æƒå€¼åˆ†ç±»ï¼Œå¹¶æ’åºã€‚

å…ˆæ±‚å‡º MST çš„æƒå€¼ `mstcost` ã€‚

å…³é”®è¾¹ï¼šå»é™¤è¿™æ¡è¾¹åï¼Œå†å¯¹å›¾æ±‚ä¸€æ¬¡ MSTï¼Œå¦‚æœå¾—åˆ°çš„ `cost < mstcost` ï¼Œè¯´æ˜è¯¥è¾¹ä¸ºå…³é”®è¾¹ã€‚å¦‚æœå»é™¤åï¼ŒMST ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆä¹Ÿèƒ½è¯´æ˜å®ƒæ˜¯å…³é”®è¾¹ã€‚

ä¼ªå…³é”®è¾¹ï¼šå¯¹å›¾æ±‚ MST è¿‡ç¨‹ä¸­ä¼˜å…ˆé€‰æ‹©è¿™æ¡è¾¹ï¼Œå¦‚æœå¾—åˆ°çš„ `cost == mstcost`ï¼Œè¯´æ˜æ”¹è¾¹ä¸ºä¼ªå…³é”®è¾¹ã€‚

```cpp
class UnionFind 
{
public:
    vector<int> root;
    int counter;
    UnionFind(int n) { root.resize(n, -1); counter = n; }
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
    void reset(int n) { root.resize(n, -1); counter = n; }
    bool merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (x != y)
        {
            root[y] = x, counter--;
            return true;
        }
        return false;
    }
};
class Solution {
public:
    map<int, vector<int>> edgemap;
    int points;
    int getMstCost(vector<vector<int>>& edges, int discard = -1, int first = -1)
    {
        UnionFind uf(points);
        int mstcost = 0;
        if (first != -1)
        {
            auto &e = edges[first];
            uf.merge(e[0], e[1]);
            mstcost += e[2];
        }
        for (auto &[w, v]: edgemap)
        {
            if (uf.counter == 1) break;
            for (int idx: v)
            {
                if (idx == discard || idx == first) continue;
                auto &e = edges[idx];
                if (uf.merge(e[0], e[1]))
                {
                    mstcost += w;
                    if (uf.counter == 1) break;
                }
            }
        }
        return uf.counter == 1 ? mstcost : -1;
    }

    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) 
    {
        points = n;
        UnionFind uf(n);

        int size = edges.size();
        for (int i=0; i<size; i++) edgemap[edges[i][2]].emplace_back(i);

        const int mstcost = getMstCost(edges);
        
        vector<int> key, fake;
        for (int i=0; i<size; i++)
        {
            int cost = getMstCost(edges, i, -1);
            if (cost == -1 || cost > mstcost)
            {
                key.emplace_back(i);
                continue;
            }
            cost = getMstCost(edges, -1, i);
            if (cost == mstcost) fake.emplace_back(i);
        }
        return {key, fake};
    }
};
```

## æ•°ç»„å½¢å¼çš„æ•´æ•°åŠ æ³•

æ—¥æœŸï¼š2021/1/22

é¢˜ç›®ï¼š[989. æ•°ç»„å½¢å¼çš„æ•´æ•°åŠ æ³•](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)

é¢˜ç›®è¯´äº†æ•°ç»„å½¢å¼ï¼Œæ‰€ä»¥æŠŠ k è½¬æ¢ä¸ºä¸€ä¸ªæ•°ç»„ï¼Œç»Ÿä¸€æŠŠä½ä½æ”¾åœ¨æ•°ç»„çš„å‰é¢ï¼Œç›¸åŠ å°±ç±»ä¼¼äºã€Œå½’å¹¶ã€ã€‚

```cpp
class Solution
{
public:
    vector<int> addToArrayForm(vector<int> &a, int k)
    {
        reverse(a.begin(), a.end());
        vector<int> b;
        while (k) b.push_back(k % 10), k /= 10;
        return add(a, b);
    }
    vector<int> add(vector<int> &a, vector<int> &b)
    {
        int len1 = a.size(), len2 = b.size();
        vector<int> c(max(len1, len2) + 1, 0);
        int i = 0, j = 0, k = 0;
        int carry = 0, t = 0;
        while (i < len1 && j < len2)
        {
            t = a[i++] + b[j++] + carry;
            carry = (t >= 10), t %= 10;
            c[k++] = t;
        }
        while (i < len1)
        {
            t = carry + a[i++];
            carry = (t >= 10), t %= 10;
            c[k++] = t;
        }
        while (j < len2)
        {
            t = carry + b[j++];
            carry = (t >= 10), t %= 10;
            c[k++] = t;
        }
        if (carry) c[k++] = carry;
        if (c.back() == 0) c.pop_back();
        reverse(c.begin(), c.end());
        return c;
    }
};
```

## è¿é€šç½‘ç»œçš„æ“ä½œæ¬¡æ•°

æ—¥æœŸï¼š2021/1/23

é¢˜ç›®ï¼š[1319. è¿é€šç½‘ç»œçš„æ“ä½œæ¬¡æ•°](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)ã€‚

è¿æ¥ n ä¸ªç‚¹éœ€è¦ n-1 æ¡è¾¹ã€‚ç”±é¢˜æ„å¯å¾—ï¼Œé¢˜ç›®æ‰€æ±‚å³ä¸ºè¿é€šåˆ†é‡æ•°å‡ 1 ã€‚

```cpp
class Solution {
public:
    vector<int> root;
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
    int makeConnected(int n, vector<vector<int>>& connections) {
        int size = connections.size();
        if (size < n - 1) return -1;
        root.resize(n, -1);
        int components = n;
        for (auto &v: connections)
        {
            int x = find(v[0]), y = find(v[1]);
            if (x != y) root[y] = x, components--;
        }
        return components-1;
    }
};
```



## æœ€é•¿è¿ç»­é€’å¢åºåˆ—

æ—¥æœŸï¼š2021/1/24

é¢˜ç›®ï¼š[674. æœ€é•¿è¿ç»­é€’å¢åºåˆ—](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)ã€‚

DP æ°´é¢˜ã€‚

çŠ¶æ€å®šä¹‰ï¼š`dp[i]` ä¸º ä»¥ `a[i]` ç»“å°¾çš„æœ€é•¿è¿ç»­å­åºåˆ—ã€‚

è½¬ç§»æ–¹ç¨‹ï¼š

```
dp[i] = dp[i-1]+1, if a[i]>a[i-1]
dp[i] = 1, otherwise
```

ä»£ç ï¼š

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) 
    {
        int n = nums.size();
        if (n == 0 || n == 1) return n;
        vector<int> dp(n, 1);
        int maxval = 1;
        for (int i=1; i<n; i++)
        {
            if (nums[i] > nums[i-1]) dp[i] = dp[i-1]+1;
            maxval = max(dp[i], maxval);
        }
        return maxval;
        
    }
};
```

ç©ºé—´ä¼˜åŒ–ï¼š

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) 
    {
        int n = nums.size();
        if (n == 0 || n == 1) return n;
        int dp = 1, maxval = 1;
        for (int i=1; i<n; i++)
        {
            if (nums[i] > nums[i-1]) dp = dp + 1;
            else dp = 1;
            maxval = max(dp, maxval);
        }
        return maxval;  
    }
};
```



## ç”±æ–œæ åˆ’åˆ†åŒºåŸŸ

æ—¥æœŸï¼š2021/1/25

é¢˜ç›®ï¼š[959. ç”±æ–œæ åˆ’åˆ†åŒºåŸŸ](https://leetcode-cn.com/problems/regions-cut-by-slashes/)ã€‚

å¹¶æŸ¥é›†ã€‚

å¯¹äºä¸€ä¸ªæ–œæ ï¼ˆ`\` å’Œ `/`ï¼‰è€Œè¨€ï¼Œæˆ‘ä»¬æŠŠå®ƒæ‰€åœ¨çš„æ ¼å­åˆ’åˆ†ä¸º 4 ä¸ªåŒºåŸŸã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="https://github.com/Sin-Kinben/PicGo/raw/master/img/20210125165108.png" style="width:200px"/>

å¦‚æœå½“å‰ä½ç½®ä¸º `/` ï¼Œé‚£ä¹ˆåˆå¹¶ `{0,1}` å’Œ `{2,3}`ï¼›å¦‚æœä¸º `\` ï¼Œé‚£ä¹ˆåˆå¹¶ `{1,2}` å’Œ `{0,3}` ; å¦‚æœä¸ºç©ºæ ¼ï¼Œåˆå¹¶ `{0,1,2,3}` .

ç°åœ¨è¦ç»™æ¯ä¸€ä¸ªå°ä¸‰è§’å½¢ä¸€ä¸ª ID ï¼ˆç”¨äºä»£è¡¨å¹¶æŸ¥é›†çš„èŠ‚ç‚¹ï¼‰ï¼Œå‡è®¾è¾“å…¥çš„ `grid` ä¸º `m * n` ï¼Œé‚£ä¹ˆæ¯è¡Œå°±æœ‰ `4n` ä¸ªä¸‰è§’å½¢ï¼Œä½ç½® `(i,j)` çš„å››ä¸ªä¸‰è§’å½¢çš„ ID ä¸º `getfield(i, j) + {0, 1, 2, 3}` ã€‚

ä»£ç ï¼š

```cpp
class Solution {
public:
    vector<int> root;
    int components;
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
    void merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (x!=y) root[y] = x, components--;
    }
    int regionsBySlashes(vector<string>& grid) {
        if (grid.size() == 0)
            return 1;
        int m = grid.size(), n = grid[0].size();
        components = 4*n*m;
        root.resize(components, -1);

        auto getfield = [n](int i, int j) { return i*4*n+j*4; };
        for (int i=0; i<m; i++)
        {
            for (int j=0; j<n; j++)
            {
                int field = getfield(i, j);
                if (grid[i][j] == '/')
                    merge(field, field+1), merge(field+2, field+3);
                else if (grid[i][j] == '\\')
                    merge(field+1, field+2), merge(field, field+3);
                else
                    merge(field, field+1), merge(field, field+2), merge(field, field+3);
                if (i-1>=0) merge(field+1, getfield(i-1, j)+3);
                if (j-1>=0) merge(field, getfield(i, j-1)+2);
            }
        }
        return components;
    }
};
```



## ç­‰ä»·å¤šç±³è¯ºéª¨ç‰Œå¯¹çš„æ•°é‡

æ—¥æœŸï¼š2021/1/26

é¢˜ç›®ï¼š[1128. ç­‰ä»·å¤šç±³è¯ºéª¨ç‰Œå¯¹çš„æ•°é‡](https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/)ã€‚

æ¡ä»¶åå°„çš„æˆ‘é©¬ä¸Šå†™äº†ä¸ªæšä¸¾ + å¹¶æŸ¥é›†ï¼Œ$O(N^2)$ æœæ–­è¶…æ—¶ã€‚

ç»“æœåŸæ¥æ˜¯å“ˆå¸Œå•Šï¼Œé‚£æ²¡äº‹äº†ã€‚ `a==c` ä¸” `b==d`ï¼Œæˆ–æ˜¯ `a==d` ä¸” `b==c` çš„ç­‰ä»·æ¡ä»¶æ˜¯ `hash(a,b) == hash(c,d)` .  æ„é€  `hash(x, y) = 10 * max(x,y) + min(x,y)` .

ä»£ç ï¼š 

```cpp
class Solution {
public:
    int numEquivDominoPairs(vector<vector<int>>& dominoes) 
    {
        int result = 0;
        int table[100] = {0};
        for (auto &v: dominoes)
        {
            int x = v[0], y = v[1];
            int val = (x > y) ? (10*x+y) : (10*y+x);
            result += table[val];
            table[val]++;
        }
        return result;
    }
};
```

## ä¿è¯å›¾å¯å®Œå…¨éå†

æ—¥æœŸï¼š2021/1/27

é¢˜ç›®ï¼š[1579. ä¿è¯å›¾å¯å®Œå…¨éå†](https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/) ã€‚

æ˜¾ç„¶ç”¨å¹¶æŸ¥é›†å•¦ã€‚é¢˜ç›®è¦æ±‚ã€Œè¿”å›å¯ä»¥åˆ é™¤çš„æœ€å¤§è¾¹æ•°ã€ï¼Œäº¦å³ï¼šæ·»åŠ æœ€å°‘çš„è¾¹æ•°ï¼Œä½¿å¾—å›¾æ»¡è¶³å…¨éå†çš„æ¡ä»¶ã€‚

æ ¹æ®é¢˜æ„ï¼Œæ˜¾ç„¶ `type=3` çš„è¾¹æ˜¯éœ€è¦ä¼˜å…ˆè€ƒè™‘çš„ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿå‡è®¾å­˜åœ¨è¾¹ `(3, a, b)`:

- å¦‚æœè¾¹é›†ä¸­ä¸å­˜åœ¨ `(1, a, b)` å’Œ `(2, a, b)`ï¼Œæˆ–è€…åªå­˜åœ¨äºŒè€…ä¸­çš„ä¸€ä¸ªï¼Œé‚£ä¹ˆ `(3,a,b)` å¿…ç„¶éœ€è¦æ·»åŠ åˆ°å›¾ä¸­ï¼ˆå¦åˆ™è‡³å°‘æœ‰ 1 ä¸ªäººä¸èƒ½å…¨éå†ï¼‰ã€‚
- å¦‚æœè¾¹é›†ä¸­åŒæ—¶å­˜åœ¨ `(1, a, b)` æˆ–è€… `(2, a, b)`, ä¸ºäº†ä½¿ Alice å’Œ Bob éƒ½èƒ½å…¨éå†ï¼Œåªæ·»åŠ  `(3,a,b)` å³å¯ï¼ˆå¦åˆ™è¦æ·»åŠ  2 æ¡è¾¹ï¼‰ã€‚

ç„¶åï¼ŒåŸºäºä¸Šè¿°çš„å¹¶æŸ¥é›†ç»“æœï¼ˆæ‹·è´ä¸€ä»½ç»“æœï¼‰ï¼Œå¯¹ Alice å’Œ Bob åˆ†åˆ«æ·»åŠ  `type=1` å’Œ `type=2` çš„è¾¹ï¼Œå¦‚æœ Alice å’Œ Bob éƒ½èƒ½å…¨éå†ï¼Œé‚£ä¹ˆå°±è¿”å› `edges.size` å‡å»æ·»åŠ çš„è¾¹æ•°ï¼Œå¦åˆ™è¿”å› -1 ã€‚

å¹¶æŸ¥é›†ä¸­çš„ `merge` è¿”å›è¯¥è¾¹æ˜¯å¦æ·»åŠ æˆåŠŸï¼Œ `counter` ç”¨äºè®¡æ•°æˆåŠŸæ·»åŠ çš„è¾¹æ•°ã€‚

```cpp
class UnionFind
{
public:
    vector<int> root;
    int components;
    UnionFind(int n):components(n) { root.resize(n, -1); }
    UnionFind(const UnionFind &uf) { root = uf.root, components = uf.components; }
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
    bool merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (x!=y)
        {
            root[y] = x, components--;
            return true;
        }
        return false;
    }
};
class Solution {
public:
    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<int>> table;
        int size = edges.size();
        for (int i=0; i<size; i++)
            table[edges[i][0]].emplace_back(i);
        UnionFind uf(n + 1);
        int counter = 0;            
        auto merge = [&](UnionFind &u, int type) {
            int a, b;
            for (int idx: table[type])
            {
                a = edges[idx][1], b = edges[idx][2];
                counter += u.merge(a, b);
            }
        };
        merge(uf, 3);
        UnionFind alice(uf), bob(uf);
        merge(alice, 1), merge(bob, 2);
        // å› ä¸º 0 å·èŠ‚ç‚¹æ€»æ˜¯å¤šä½™çš„ï¼Œæ‰€ä»¥è¿é€šåˆ†é‡ä¸ªæ•°ä¸º 2 è¯´æ˜å…¨éå†
        return (alice.components != 2 || bob.components != 2) ? -1 : (size - counter);
    }
};
```

## å¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒç´¢å¼•

æ—¥æœŸï¼š2021/1/28

é¢˜ç›®ï¼š[724. å¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒç´¢å¼•](https://leetcode-cn.com/problems/find-pivot-index/) 

å‰ç¼€å’Œã€‚ä½†éœ€è¦æ³¨æ„è¾¹ç•Œæƒ…å†µï¼š

- `n <= 1`
- `[x, 1, -1]` è¿™ä¸€ç±»æƒ…å†µåº”å½“è¿”å› 0 

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int n = nums.size();
        if (n <= 1) return -1;
        vector<int> prefixsum(nums);
        for (int i=1; i<n; i++)
            prefixsum[i] += prefixsum[i-1];
        if (prefixsum[n-1] - prefixsum[0] == 0) return 0;
        for (int x=1; x<n; x++)
        {
            if (prefixsum[x-1] == (prefixsum[n-1] - prefixsum[x]))
                return x;
        }
        return -1;
    }
};
```

## æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„

æ—¥æœŸï¼š2021/1/29

é¢˜ç›®ï¼š[1631. æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„](https://leetcode-cn.com/problems/path-with-minimum-effort/)

æŸæ¬¡å‘¨èµ›çš„é¢˜ç›®ï¼šhttps://www.cnblogs.com/sinkinben/p/13873825.html

è§£æ³•ï¼šäºŒåˆ†æŸ¥æ‰¾+DFS/BFSï¼Œå¹¶æŸ¥é›†ã€‚

å¹¶æŸ¥é›†è§£æ³•ï¼šæ¯ä¸ªæ ¼å­æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé«˜åº¦ä¹‹å·®æ˜¯è¾¹çš„æƒå€¼ï¼Œå¯¹è¾¹ä»å°åˆ°å¤§æ’åºï¼Œä¾æ¬¡åŠ å…¥å¹¶æŸ¥é›†ï¼Œç›´åˆ° `(0,0)` å’Œ `(rows-1, cols-1)` è¿é€šã€‚

æ³¨æ„åˆ°ï¼š**ä½“åŠ›å€¼**æ˜¯è·¯å¾„ä¸Šç›¸é‚»æ ¼å­ä¹‹é—´ **é«˜åº¦å·®ç»å¯¹å€¼** çš„ **æœ€å¤§å€¼** å†³å®šçš„ã€‚å› æ­¤ï¼Œåœ¨åŠ å…¥å¹¶æŸ¥é›†çš„è¾¹ä¸­ï¼Œæœ€å¤§æƒå€¼çš„è¾¹å°±æ˜¯ä»£è¡¨è¯¥è·¯å¾„çš„ä½“åŠ›æ¶ˆè€—å€¼ï¼Œä¹Ÿå°±æ˜¯ã€Œæœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„ã€çš„ä½“åŠ›æ¶ˆè€—å€¼ã€‚

```cpp
struct edge 
{
    int x, y, cost;
    edge(int _x, int _y, int _cost):x(_x), y(_y), cost(_cost) {};
    bool operator < (const edge &e) const { return cost > e.cost; }
};
class Solution {
public:
    int rows, cols;
    vector<int> root;
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
    int minimumEffortPath(vector<vector<int>>& heights) {
        if (heights.size() == 0 || heights[0].size() == 0) return 0;
        rows = heights.size(), cols = heights[0].size();
        root.resize(rows * cols, -1);

        priority_queue<edge> q;
        auto getid = [=](int i, int j) { return i*cols+j; };
        for (int i=0; i<rows; i++)
        {
            for (int j=0; j<cols; j++)
            {
                int id = getid(i, j);
                if (i+1<rows) q.emplace(id, getid(i+1, j), abs(heights[i][j] - heights[i+1][j]));
                if (j+1<cols) q.emplace(id, getid(i, j+1), abs(heights[i][j] - heights[i][j+1]));
            }
        }
        int ans = 0;
        while (!q.empty())
        {
            auto e = q.top();
            q.pop();
            int x = find(e.x), y = find(e.y);
            if (x != y)
            {
                ans = max(ans, e.cost);
                root[y] = x;
                if (find(0) == find(rows*cols-1)) break;
            }
        }
        return ans;
    }
};
```

## æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³

æ—¥æœŸï¼š2021/1/30

é¢˜ç›®ï¼š[778. æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³](https://leetcode-cn.com/problems/swim-in-rising-water/)

è·Ÿæ˜¨å¤©ä¸€é¢˜ç±»ä¼¼ï¼Œä½¿ç”¨å¹¶æŸ¥é›†ï¼ˆå½“ç„¶ä¹Ÿå¯ä»¥äºŒåˆ†+DFS/BFSï¼‰ã€‚

å¯¹è¾¹æ’åºï¼ˆæƒå€¼ä¸ºä¸¤ç‚¹ä¹‹é—´çš„æœ€é«˜æ°´ä½ï¼‰ï¼Œä»å°åˆ°å¤§æ·»åŠ å…¥å¹¶æŸ¥é›†ï¼Œç›´åˆ°å·¦ä¸Šè§’è·Ÿå³ä¸‹è§’è¿é€šã€‚åœ¨æ·»åŠ å…¥å¹¶æŸ¥é›†çš„è¾¹å½“ä¸­ï¼Œæƒå€¼æœ€å¤§çš„è¾¹å³ä¸ºæ‰€æ±‚ã€‚

ä»£ç ï¼š

```cpp
struct edge 
{
    int x, y, cost;
    edge(int _x, int _y, int _cost):x(_x), y(_y), cost(_cost) {}
    bool operator < (const edge &e) const { return cost > e.cost; }
};
class Solution {
public:
    vector<int> root;
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
    bool merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (x!=y)
        {
            root[y] = x;
            return true;
        }
        return false;
    }
    int swimInWater(vector<vector<int>>& grid) {
        int n = grid.size();
        root.resize(n*n, -1);
        auto getid = [n](int i, int j) {return i*n+j;};
        priority_queue<edge> q;
        for (int i=0; i<n; i++)
        {
            for (int j=0; j<n; j++)
            {
                int id = getid(i, j);
                if (j+1<n) q.emplace(id, getid(i, j+1), max(grid[i][j], grid[i][j+1]));
                if (i+1<n) q.emplace(id, getid(i+1, j), max(grid[i][j], grid[i+1][j]));   
            }
        }
        int ans = 0;
        while (!q.empty())
        {
            auto e = q.top();
            q.pop();
            if (merge(e.x, e.y))
            {
                ans = max(ans, e.cost);
                if (find(0) == find(n*n-1)) break;
            }
        }
        return ans;
    }
};
```

## ç›¸ä¼¼å­—ç¬¦ä¸²ç»„

æ—¥æœŸï¼š2021/1/31

é¢˜ç›®ï¼š[839. ç›¸ä¼¼å­—ç¬¦ä¸²ç»„](https://leetcode-cn.com/problems/similar-string-groups/)ã€‚

ç”¨å¹¶æŸ¥é›†æš´åŠ›æšä¸¾ï¼Œæœ€åè¿”å›è¿é€šåˆ†é‡çš„ä¸ªæ•°ã€‚æ³¨æ„åˆ°ï¼šæ‰€æœ‰å•è¯éƒ½å…·æœ‰ç›¸åŒçš„é•¿åº¦ï¼Œä¸”æ˜¯å½¼æ­¤çš„å­—æ¯å¼‚ä½è¯ã€‚å› æ­¤ `similar` çš„æ¡ä»¶æ˜¯æœ‰ä¸”åªæœ‰ 2 ä¸ªå­—ç¬¦ä¸åŒã€‚

è®¾ $m$ ä¸º `strs` çš„å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œ$n$ ä¸ºæ•°ç»„é•¿åº¦ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸º $O(mn^2 + n \log{n})$ .  è€ƒè™‘é¢˜ç›®ç»™å‡ºçš„æ•°æ®è§„æ¨¡ï¼Œè¿™æ˜¯èƒ½å¤Ÿæ¥å—çš„ã€‚

```cpp
class Solution {
public:
    vector<int> root;
    int components;
    int find(int x) { return root[x] == -1 ? x : root[x] = find(root[x]); }
    void merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (x!=y) root[y] = x, components--;
    }
    int numSimilarGroups(vector<string>& strs) 
    {
        int size = strs.size();
        root.resize(size, -1), components = size;
        for (int i=0; i<size; i++)
        {
            for (int j=i+1; j<size; j++)
                if (similar(strs[i], strs[j]))
                    merge(i, j);
        }
        return components;
    }
    bool similar(string &a, string &b)
    {
        int len = a.length(), diff = 0;
        for (int i=0; i<len; i++) diff += (a[i] != b[i]);
        return diff <= 2;
    }
};
```

å¹¶æŸ¥é›†ä¹‹æœˆï¼Œå®Œç»“æ’’èŠ± ğŸŒ¸ ï¼